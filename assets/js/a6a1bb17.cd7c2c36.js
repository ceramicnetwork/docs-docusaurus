"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7070],{78138:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var o=t(11527),i=t(63883);const s={},a="TACo with ComposeDB",r={id:"composedb/examples/taco-access-control",title:"TACo with ComposeDB",description:"Store sensitive data on ComposeDB, using decentralized access control to enforce fine-grained decryption rights.",source:"@site/docs/composedb/examples/taco-access-control.mdx",sourceDirName:"composedb/examples",slug:"/composedb/examples/taco-access-control",permalink:"/docs/composedb/examples/taco-access-control",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"composedb",previous:{title:"Verifiable Credentials",permalink:"/docs/composedb/examples/verifiable-credentials"},next:{title:"Guides",permalink:"/docs/composedb/guides/"}},c={},d=[{value:"TACo Overview",id:"taco-overview",level:2},{value:"Use Cases",id:"use-cases",level:3},{value:"Example Application &amp; Repo",id:"example-application--repo",level:2},{value:"Specifying access conditions &amp; authentication methods",id:"specifying-access-conditions--authentication-methods",level:3},{value:"Encrypting &amp; saving the data",id:"encrypting--saving-the-data",level:3},{value:"Querying &amp; decrypting the data",id:"querying--decrypting-the-data",level:3},{value:"Using ComposeDB &amp; TACo in production",id:"using-composedb--taco-in-production",level:3}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"taco-with-composedb",children:"TACo with ComposeDB"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.em,{children:"Store sensitive data on ComposeDB, using decentralized access control to enforce fine-grained decryption rights."})}),"\n",(0,o.jsxs)(n.p,{children:["This guide explains how to integrate ",(0,o.jsx)(n.a,{href:"https://docs.threshold.network/applications/threshold-access-control",children:"TACo"})," into ComposeDB, which enables the storing and sharing of non-public data on Ceramic. A more detailed version of this tutorial is available ",(0,o.jsx)(n.a,{href:"https://docs.threshold.network/app-development/threshold-access-control-tac/integration-guides/ceramic-+-taco",children:"here"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"taco-overview",children:"TACo Overview"}),"\n",(0,o.jsx)(n.p,{children:"TACo is a programmable encrypt/decrypt API for applications that handle sensitive user data, without compromising on privacy, security or decentralization. TACo offers a distinct alternative to centralized, permissioned, and TEE-dependent access control services."}),"\n",(0,o.jsx)(n.p,{children:"TACo is the first and only end-to-end encrypted data sharing layer in which access to data payloads is always collectively enforced by a distributed group. Today, over 120 service-providers permissionlessly run TACo clients. They independently validate whether a given data request satisfies pre-specified conditions, only then provisioning decryption material fragments for client-side assembly, decryption, and plaintext access."}),"\n",(0,o.jsx)(n.p,{children:"TACo offers a flexible access control framework and language, in which access conditions can be configured individually and combined logically. Developers can compose dynamic access workflows for their users \u2013 for example, using\nthe sequential conditions feature to predicate the input to a given access condition on the output of a previous condition or call. Conditions may also be programmatically combined with both on-chain and off-chain authentication methods."}),"\n",(0,o.jsxs)(n.p,{children:["TACo\u2019s encrypt/decrypt API \u2013 ",(0,o.jsx)(n.a,{href:"https://github.com/nucypher/taco-web",children:"taco-web"})," \u2013 is straightforward to integrate into any web app and usable in parallel with core Web3 infrastructure like Ceramic."]}),"\n",(0,o.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Social networks & Knowledge Bases:"})," Leverage Ceramic's verifiable credentials and TACo's credential-based decryption to ensure that private user-generated content is only viewable by those who are supposed to see it, and nobody else."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"IoT event streams:"})," Let data flow from sensors to legitimate recipients, without trusting an intermediary server to handle the routing and harvest sensitive (meta)data. For example, a medical professional can be issued a temporary access token if the output data from a patient's wearable device rises above a certain threshold."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"LLM chatbots:"})," Messages to and from a chatbot should be 100% private, not mined by a UX-providing intermediary. Harness Ceramic's web-scale transaction processing and TACo's per-message encryption/condition granularity to provide a smooth and safe experience for users of LLM interfaces."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"example-application--repo",children:"Example Application & Repo"}),"\n",(0,o.jsxs)(n.p,{children:['The "TACo with ComposeDB Message Board ',(0,o.jsx)(n.a,{href:"https://github.com/nucypher/taco-composedb/tree/main",children:"Application"}),'" is provided as an example and reference for developers \u2013 illustrating how TACo and ComposeDB can be combined in a browser-based messaging app. Once installed, a simple UI shows how messages can be encrypted by data producers with access conditions embedded, and how data consumers can view messages ',(0,o.jsx)(n.em,{children:"only"})," if they satisfy those conditions. Launching the demo also involves running a local Ceramic node, to which TACo-encrypted messages are saved and immediately queryable by data requestors."]}),"\n",(0,o.jsx)(n.p,{children:"The following sections explain the core components of TACo\u2019s access control system \u2013 access conditions, encryption, and decryption."}),"\n",(0,o.jsx)(n.h3,{id:"specifying-access-conditions--authentication-methods",children:"Specifying access conditions & authentication methods"}),"\n",(0,o.jsx)(n.p,{children:"There are two ways in which a recipient, or data consumer, must prove their right to access the private data \u2013 (1) authentication and (2) condition fulfillment. The data producer must specify the authentication methods and condition(s) before encrypting the private data, as this configuration is embedded alongside the encrypted payload."}),"\n",(0,o.jsxs)(n.p,{children:["In the example snippet below, we are using RPC conditions. The function will check the ",(0,o.jsx)(n.em,{children:"data consumer\u2019s"})," Ethereum wallet balance, which they prove ownership of via the chosen authentication method \u2013 in this case via a EIP4361 (Sign-In with Ethereum) message. Note that this message has already been solicited and utilized by the application, analogous to single-sign-on functionality. This setup is the same as in the demo code above and can be viewed directly in the ",(0,o.jsx)(n.a,{href:"https://github.com/nucypher/taco-composedb/blob/main/src/fragments/chatinputbox.tsx#L26-L34",children:"repo"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"import { conditions } from \"@nucypher/taco\"; \n\nconst rpcCondition = new conditions.base.rpc.RpcCondition({\n    chain: 80002,\n    method: 'eth_getBalance',\n    parameters: [':userAddressExternalEIP4361'],\n    returnValueTest: {\n        comparator: '>',\n        value: 0,\n    },\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"encrypting--saving-the-data",children:"Encrypting & saving the data"}),"\n",(0,o.jsxs)(n.p,{children:["To complete the encryption step, the following are added as arguments:\na. ",(0,o.jsx)(n.code,{children:"domain"})," \u2013 testnet or mainnet\nb. ",(0,o.jsx)(n.code,{children:"ritualId"}),"  \u2013 the ID of the cohort of TACo nodes who will collectively manage access to the data\nc. a standard web3 provider"]}),"\n",(0,o.jsx)(n.p,{children:"The output of this function is a payload containing both the encrypted data and embedded metadata necessary for a qualifying data consumer to access the plaintext message."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:'import { initialize, encrypt, conditions, domains, toHexString } from \'@nucypher/taco\';\nimport { ethers } from "ethers";\n\nawait initialize();\n\nconst web3Provider = new ethers.providers.Web3Provider(window.ethereum);\nconst ritualId = 0\nconst message = "I cannot trust a centralized access control layer with this message.";\nconst messageKit = await encrypt(\n    web3Provider,\n    domains.TESTNET,\n    Message,\n    rpcCondition,\n    ritualId,\n    web3Provider.getSigner()\n);\nconst encryptedMessageHex = toHexString(messageKit.toBytes());\n'})}),"\n",(0,o.jsx)(n.h3,{id:"querying--decrypting-the-data",children:"Querying & decrypting the data"}),"\n",(0,o.jsxs)(n.p,{children:["Data consumers interact with the TACo API via the ",(0,o.jsx)(n.code,{children:"decrypt"})," function. They include the following arguments:"]}),"\n",(0,o.jsxs)(n.p,{children:["a. ",(0,o.jsx)(n.code,{children:"provider"}),"\nb. ",(0,o.jsx)(n.code,{children:"domain"}),"\nc. ",(0,o.jsx)(n.code,{children:"encryptedMessage"}),"\nd. ",(0,o.jsx)(n.code,{children:"conditionContext"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"conditionContext"})," is a way for developers to programmatically map methods for authenticating a data consumer to specific access conditions \u2013 all executable at decryption time. For example, if the condition involves proving ownership of a social account, authenticate via OAuth."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-TypeScript",children:"import {conditions, decrypt, Domain, encrypt, ThresholdMessageKit} from '@nucypher/taco';\nimport {ethers} from \"ethers\";\n\nexport async function decryptWithTACo(\n    encryptedMessage: ThresholdMessageKit,\n    domain: Domain,\n    conditionContext?: conditions.context.ConditionContext\n): Promise<Uint8Array> {\n    const provider = new ethers.providers.Web3Provider(window.ethereum);\n    return await decrypt(\n        provider,\n        domain,\n        encryptedMessage,\n        conditionContext,\n    )\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Note that the EIP4361 authentication data required to validate the user address (within the condition) is supplied via the ",(0,o.jsx)(n.code,{children:"conditionContext"})," object. To understand this component better, check out the demo ",(0,o.jsx)(n.a,{href:"https://github.com/nucypher/taco-composedb/blob/main/src/fragments/chatcontent.tsx#L47",children:"repo"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"using-composedb--taco-in-production",children:"Using ComposeDB & TACo in production"}),"\n",(0,o.jsxs)(n.p,{children:["For Ceramic, connect to Mainnet (",(0,o.jsx)(n.code,{children:"domains.MAINNET"}),")."]}),"\n",(0,o.jsx)(n.p,{children:"For TACo, a funded Mainnet ritualID is required \u2013 this connects the encrypt/decrypt API to a cohort of independently operated nodes and corresponds to a DKG public key generated by independent parties. A dedicated ritualID for Ceramic + TACo projects will be sponsored soon. Watch for updates here."})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},63883:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>a});var o=t(50959);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);
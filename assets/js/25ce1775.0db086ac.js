"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1613],{35888:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var t=n(11527),r=n(63883);const i={},o="Tip Queries",a={id:"protocol/js-ceramic/networking/tip-queries",title:"Tip Queries",description:"Ceramic streams are identified by a URI called StreamIds. Nodes that want to sync a stream need to query the network for the tip of that stream using its StreamId.",source:"@site/docs/protocol/js-ceramic/networking/tip-queries.md",sourceDirName:"protocol/js-ceramic/networking",slug:"/protocol/js-ceramic/networking/tip-queries",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/networking/tip-queries",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"protocol",previous:{title:"Tip Gossip",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/networking/tip-gossip"},next:{title:"Event Fetching",permalink:"/docs-docusaurus/docs/protocol/js-ceramic/networking/event-fetching"}},c={},d=[{value:"Protocol",id:"protocol",level:2},{value:"<strong>Query Message</strong>",id:"query-message",level:3},{value:"<strong>Response Message</strong>",id:"response-message",level:3},{value:"Examples",id:"examples",level:2},{value:"TypeScript Definitions",id:"typescript-definitions",level:3}];function l(e){const s={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"tip-queries",children:"Tip Queries"}),"\n",(0,t.jsxs)(s.p,{children:["Ceramic streams are identified by a ",(0,t.jsx)(s.a,{href:"../streams/uri-scheme",children:"URI"})," called StreamIds. Nodes that want to sync a stream need to query the network for the tip of that stream using its StreamId."]}),"\n",(0,t.jsx)(s.p,{children:"!!!note\nTips are the most recent Init, Data, or Time event for a given Stream Tip"}),"\n",(0,t.jsx)(s.h2,{id:"protocol",children:"Protocol"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsxs)(s.p,{children:["A node resolving a Ceramic URI sends a query message to the network and then listens for responses with the candidates for the current tip of the stream. Any node that is interested in the same stream on the network and has stored its tips will respond with a response message. All messages are sent on the ",(0,t.jsx)(s.a,{href:"https://github.com/libp2p/specs/tree/master/pubsub",children:"libp2p pubsub"})," topic for the ",(0,t.jsx)(s.a,{href:"/docs-docusaurus/docs/protocol/js-ceramic/networking/networks",children:"network"})," the node is configured for."]}),"\n",(0,t.jsx)(s.h3,{id:"query-message",children:(0,t.jsx)(s.strong,{children:"Query Message"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-tsx",children:"type QueryMessage = {\n  typ: MsgType.QUERY // 1\n  id: string\n  stream: StreamID\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Where:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"typ"})})," - the message is a query message, enum ",(0,t.jsx)(s.code,{children:"1"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"stream"})})," - the streamId that is being queried or resolved"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"id"})})," - a multihash ",(0,t.jsx)(s.code,{children:"base64url.encode(sha265(dagCBOR({typ:1, stream: streamId})))"}),", can generally be treated as a random string that is used to pair queries to responses"]}),"\n"]}),"\n",(0,t.jsx)(s.h3,{id:"response-message",children:(0,t.jsx)(s.strong,{children:"Response Message"})}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-tsx",children:"type ResponseMessage = {\n  typ: MsgType.RESPONSE // 2\n  id: string\n  tips: Map<StreamId, CID> \n}\n"})}),"\n",(0,t.jsx)(s.p,{children:"Where:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"typ"})})," - the message is a response message, enum ",(0,t.jsx)(s.code,{children:"2"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"id"})})," - id of the query that this message is a response to"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.strong,{children:(0,t.jsx)(s.code,{children:"tips"})})," - map of ",(0,t.jsx)(s.code,{children:"StreamID"})," to CID of stream tip"]}),"\n"]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["Currently this will only ever have a single ",(0,t.jsx)(s.code,{children:"StreamID"})," in the query, but Ceramic will likely have batch queries at some point in the future."]})}),"\n",(0,t.jsx)(s.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(s.hr,{}),"\n",(0,t.jsx)(s.h3,{id:"typescript-definitions",children:"TypeScript Definitions"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-tsx",children:"enum MsgType { // Ceramic Pub/Sub message type.\n  UPDATE = 0,\n  QUERY = 1,\n  RESPONSE = 2,\n  KEEPALIVE = 3,\n}\n\ntype QueryMessage = {\n  typ: MsgType.QUERY\n  id: string\n  stream: StreamID\n}\n\ntype ResponseMessage = {\n  typ: MsgType.RESPONSE\n  id: string\n  tips: Map<string, CID>\n}\n"})})]})}function h(e={}){const{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},63883:(e,s,n)=>{n.d(s,{Z:()=>a,a:()=>o});var t=n(50959);const r={},i=t.createContext(r);function o(e){const s=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:s},e.children)}}}]);
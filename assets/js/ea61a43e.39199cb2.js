"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7794],{7154:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var i=n(11527),a=n(63883);const s={},o="DID JSON-RPC client",r={id:"protocol/js-ceramic/guides/ceramic-clients/authentication/did-jsonrpc",title:"DID JSON-RPC client",description:"---",source:"@site/docs/protocol/js-ceramic/guides/ceramic-clients/authentication/did-jsonrpc.md",sourceDirName:"protocol/js-ceramic/guides/ceramic-clients/authentication",slug:"/protocol/js-ceramic/guides/ceramic-clients/authentication/did-jsonrpc",permalink:"/docs/protocol/js-ceramic/guides/ceramic-clients/authentication/did-jsonrpc",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"protocol",previous:{title:"Pinning",permalink:"/docs/protocol/js-ceramic/guides/ceramic-clients/javascript-clients/pinning"},next:{title:"Key DID libraries",permalink:"/docs/protocol/js-ceramic/guides/ceramic-clients/authentication/key-did"}},c={},d=[{value:"Things to know",id:"things-to-know",level:2},{value:"Installation",id:"installation",level:2},{value:"Choose your account types",id:"choose-your-account-types",level:2},{value:"PKH DID",id:"pkh-did",level:3},{value:"Key DID",id:"key-did",level:3},{value:"Install account resolvers",id:"install-account-resolvers",level:2},{value:"Install account providers",id:"install-account-providers",level:2},{value:"Using web wallets",id:"using-web-wallets",level:3},{value:"Create your own wallet",id:"create-your-own-wallet",level:3},{value:"Setup your project",id:"setup-your-project",level:2},{value:"Common use-cases",id:"common-use-cases",level:2},{value:"Authenticate the user",id:"authenticate-the-user",level:3},{value:"Enable Ceramic transactions",id:"enable-ceramic-transactions",level:3},{value:"Resolve a DID document",id:"resolve-a-did-document",level:3},{value:"Store signed data on IPFS using DagJWS",id:"store-signed-data-on-ipfs-using-dagjws",level:3},{value:"How it Works",id:"how-it-works",level:5},{value:"Store encrypted data on IPFS with DagJWE",id:"store-encrypted-data-on-ipfs-with-dagjwe",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h5:"h5",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"did-json-rpc-client",children:"DID JSON-RPC client"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.p,{children:"DID JSON-RPC client provides a simple JS API for interacting with Ceramic accounts."}),"\n",(0,i.jsx)(t.h2,{id:"things-to-know",children:"Things to know"}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Provides the DID object, which must be authenticated, then mounted on the Ceramic object to perform transactions."}),"\n",(0,i.jsx)(t.li,{children:"For Ceramic nodes, the DID client acts as a way to resolve and verify transaction signatures"}),"\n",(0,i.jsx)(t.li,{children:"For Ceramic clients, the DID client serves as a way to create an account, authenticate, sign, encrypt"}),"\n",(0,i.jsxs)(t.li,{children:["If your project requires transactions, you ",(0,i.jsx)(t.strong,{children:"need"})," to install this package or one that offers similar EIP-2844 API support."]}),"\n",(0,i.jsx)(t.li,{children:"The DID client library can be used in both browser and Node.js environments."}),"\n",(0,i.jsxs)(t.li,{children:["It supports any DID wallet provider that adheres to the ",(0,i.jsx)(t.a,{href:"https://eips.ethereum.org/EIPS/eip-2844",children:"EIP-2844"})," interface."]}),"\n",(0,i.jsx)(t.li,{children:"Communicating between a Ceramic client and any account provider."}),"\n",(0,i.jsx)(t.li,{children:"Ceramic does not work without a DID client, as it is how all participants are identified and how transactions and messages are signed and verified."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"installation",children:"Installation"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sh",children:"npm install dids\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"DID"})," class provides the interface on top of underlying account libraries. The next step is to set up your account system, which requires you to make some important decisions about your account model and approach to key management. This process consists of three steps: choosing your account types, installing a provider, and installing resolver(s)."]}),"\n",(0,i.jsx)(t.h2,{id:"choose-your-account-types",children:"Choose your account types"}),"\n",(0,i.jsx)(t.p,{children:"Choosing an account type can significantly impact your users' identity and data interoperability.  For example, some account types are fixed to a single public key (Key DID, PHK DID), so the data is siloed to that key.  In contrast, others (3ID DID) have mutable key management schemes that can support multiple authorized signing keys and works cross-chain with blockchain wallets. Visit each account to learn more about its capabilities."}),"\n",(0,i.jsx)(t.h3,{id:"pkh-did",children:(0,i.jsx)(t.a,{href:"/docs/protocol/js-ceramic/accounts/decentralized-identifiers#pkh-did",children:"PKH DID"})}),"\n",(0,i.jsx)(t.p,{children:"Based on Sign-in with Ethereum, or similar standards in other blockchain ecosystems. Good for users + most popular. Relies on existing wallet infrastructure."}),"\n",(0,i.jsx)(t.h3,{id:"key-did",children:(0,i.jsx)(t.a,{href:"/docs/protocol/js-ceramic/accounts/decentralized-identifiers#key-did",children:"Key DID"})}),"\n",(0,i.jsx)(t.p,{children:"Simple, self-contained DID method."}),"\n",(0,i.jsx)(t.h2,{id:"install-account-resolvers",children:"Install account resolvers"}),"\n",(0,i.jsxs)(t.p,{children:["The next step is to install resolver libraries for all account types that you may need to read and verify data (signatures). This includes ",(0,i.jsx)(t.em,{children:"at least"})," the resolver for the provider or wallet chosen in the previous step. However, most projects install all resolvers to be safe:"]}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Account"}),(0,i.jsx)(t.th,{children:"Resolver libraries"}),(0,i.jsx)(t.th,{children:"Maintainer"})]})}),(0,i.jsx)(t.tbody,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Key DID"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"/docs/protocol/js-ceramic/guides/ceramic-clients/authentication/key-did#key-did-resolver",children:(0,i.jsx)(t.code,{children:"key-did-resolver"})})}),(0,i.jsx)(t.td,{children:"3Box Labs"})]})})]}),"\n",(0,i.jsx)(t.h2,{id:"install-account-providers",children:"Install account providers"}),"\n",(0,i.jsx)(t.p,{children:"Install providers to manage accounts and sign transactions. Once you have chosen one or more account types, you'll need to install the providers for these account types. These will enable the client-side creation and use of accounts within your application. If your application uses Ceramic in a read-only manner without transactions, you do not need to install a provider."}),"\n",(0,i.jsx)(t.h3,{id:"using-web-wallets",children:"Using web wallets"}),"\n",(0,i.jsx)(t.p,{children:"However, the providers listed above are low-level, run locally, and burden developers with UX issues related to secret key management and transaction signing. Instead of using a local provider, you can alternatively use a wallet system. Wallets wrap providers with additional user experience features related to signing and key management and can be used in place of a provider. The benefit is multiple applications can access the same wallet and key management system, so users have a continuous experience between applications."}),"\n",(0,i.jsx)(t.h3,{id:"create-your-own-wallet",children:"Create your own wallet"}),"\n",(0,i.jsx)(t.p,{children:"One option is installing and setting up one or more account providers that run locally. Note that these local signers have different wallet support"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Account"}),(0,i.jsx)(t.th,{children:"Supported Key Types"}),(0,i.jsx)(t.th,{children:"Provider libraries"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Key DID"}),(0,i.jsx)(t.td,{children:"Ed25519"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"/docs/protocol/js-ceramic/guides/ceramic-clients/authentication/key-did#ed25519",children:(0,i.jsx)(t.code,{children:"key-did-provider-ed25519"})})})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"Key DID"}),(0,i.jsx)(t.td,{children:"Secp256k1"}),(0,i.jsx)(t.td,{children:(0,i.jsx)(t.a,{href:"/docs/protocol/js-ceramic/guides/ceramic-clients/authentication/key-did#secp256k1",children:(0,i.jsx)(t.code,{children:"key-did-provider-secp256k1"})})})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Note that NFT DID and Safe DID do not have a signer because they are compatible with all other providers."}),"\n",(0,i.jsx)(t.h2,{id:"setup-your-project",children:"Setup your project"}),"\n",(0,i.jsx)(t.p,{children:"You should have installed DID.js and set up your account system, including authentication to perform transactions. When you include everything in your project, it should look like this. Note that the exact code will vary by your setup, including provider and wallet. Consult your provider's documentation for authentication specifics."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"// Import DID client\nimport { DID } from 'dids'\n\n// Add account system\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// Connect to a Ceramic node\nconst API_URL = 'https://your-ceramic-node.com'\n\n// Create the Ceramic object\nconst ceramic = new CeramicClient(API_URL)\n\n// \u2191 With this setup, you can perform read-only queries.\n// \u2193 Continue to authenticate the account and perform transactions.\n\nasync function authenticateCeramic(seed) {\n  // Activate the account by somehow getting its seed.\n  // See further down this page for more details on\n  // seed format, generation, and key management.\n  const provider = new Ed25519Provider(seed)\n  // Create the DID object\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate with the provider\n  await did.authenticate()\n  // Mount the DID object to your Ceramic object\n  ceramic.did = did\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"common-use-cases",children:"Common use-cases"}),"\n",(0,i.jsx)(t.h3,{id:"authenticate-the-user",children:"Authenticate the user"}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsx)(t.p,{children:"This will flow will vary slightly depending on which account provider library you use. Please see the documentation specific to your provider library."})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\n// `seed` must be a 32-byte long Uint8Array\nasync function createJWS(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // This will throw an error if the DID instance is not authenticated\n  const jws = await did.createJWS({ hello: 'world' })\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"enable-ceramic-transactions",children:"Enable Ceramic transactions"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { CeramicClient } from '@ceramicnetwork/http-client'\nimport { DID } from 'dids'\nimport { Ed25519Provider } from 'key-did-provider-ed25519'\nimport { getResolver } from 'key-did-resolver'\n\nconst ceramic = new CeramicClient()\n\n// `seed` must be a 32-byte long Uint8Array\nasync function authenticateCeramic(seed) {\n  const provider = new Ed25519Provider(seed)\n  const did = new DID({ provider, resolver: getResolver() })\n  // Authenticate the DID with the provider\n  await did.authenticate()\n  // The Ceramic client can create and update streams using the authenticated DID\n  ceramic.did = did\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"resolve-a-did-document",children:"Resolve a DID document"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import { DID } from 'dids'\nimport { getResolver } from 'key-did-resolver'\n\n// See https://github.com/decentralized-identity/did-resolver\nconst did = new DID({ resolver: getResolver() })\n\n// Resolve a DID document\nawait did.resolve('did:key:...')\n"})}),"\n",(0,i.jsx)(t.h3,{id:"store-signed-data-on-ipfs-using-dagjws",children:"Store signed data on IPFS using DagJWS"}),"\n",(0,i.jsx)(t.p,{children:"The DagJWS functionality of the DID library can be used in conjunction with IPFS."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const payload = { some: 'data' }\n\n// sign the payload as dag-jose\nconst { jws, linkedBlock } = await did.createDagJWS(payload)\n\n// put the JWS into the ipfs dag\nconst jwsCid = await ipfs.dag.put(jws, {\n  format: 'dag-jose',\n  hashAlg: 'sha2-256',\n})\n\n// put the payload into the ipfs dag\nconst block = await ipfs.block.put(linkedBlock, { cid: jws.link })\n\n// get the value of the payload using the payload cid\nconsole.log((await ipfs.dag.get(jws.link)).value)\n// output:\n// > { some: 'data' }\n\n// alternatively get it using the ipld path from the JWS cid\nconsole.log((await ipfs.dag.get(jwsCid, { path: '/link' })).value)\n// output:\n// > { some: 'data' }\n\n// get the jws from the dag\nconsole.log((await ipfs.dag.get(jwsCid)).value)\n// output:\n// > {\n// >   payload: 'AXESINDmZIeFXbbpBQWH1bXt7F2Ysg03pRcvzsvSc7vMNurc',\n// >   signatures: [\n// >     {\n// >       protected: 'eyJraWQiOiJkaWQ6Mzp1bmRlZmluZWQ_dmVyc2lvbj0wI3NpZ25pbmciLCJhbGciOiJFUzI1NksifQ',\n// >       signature: 'pNz3i10YMlv-BiVfqBbHvHQp5NH3x4TAHQ5oqSmNBUx1DH_MONa_VBZSP2o9r9epDdbRRBLQjrIeigdDWoXrBQ'\n// >     }\n// >   ],\n// >   link: CID(bafyreigq4zsipbk5w3uqkbmh2w2633c5tcza2n5fc4x45s6soo54ynxk3q)\n// > }\n"})}),"\n",(0,i.jsx)(t.h5,{id:"how-it-works",children:"How it Works"}),"\n",(0,i.jsx)(t.p,{children:"As can be observed above, the createDagJWS method takes the payload, encodes it using dag-cbor, and computes its CID. It then uses this CID as the payload of the JWS that is then signed. The JWS that was just created can be put into ipfs using the dag-jose codec. Returned is also the encoded block of the payload. This can be put into ipfs using ipfs.block.put. Alternatively, ipfs.dag.put(payload) would have the same effect."}),"\n",(0,i.jsx)(t.h3,{id:"store-encrypted-data-on-ipfs-with-dagjwe",children:"Store encrypted data on IPFS with DagJWE"}),"\n",(0,i.jsx)(t.p,{children:"The DagJWE functionality allows us to encrypt IPLD data to one or multiple DIDs. The resulting JWE object can then be put into ipfs using the dag-jose codec. A user that is authenticated can at a later point decrypt this object."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const cleartext = { some: 'data', coolLink: new CID('bafyqacnbmrqxgzdgdeaui') }\n\n// encrypt the cleartext object\nconst jwe = await did.createDagJWE(cleartext, [\n  'did:3:bafy89h4f9...',\n  'did:key:za234...',\n])\n\n// put the JWE into the ipfs dag\nconst jweCid = await ipfs.dag.put(jwe, {\n  format: 'dag-jose',\n  hashAlg: 'sha2-256',\n})\n\n// get the jwe from the dag and decrypt it\nconst dagJWE = await ipfs.dag.get(jweCid)\nconsole.log(await did.decryptDagJWE(dagJWE))\n// output:\n// > { some: 'data' }\n"})})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},63883:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var i=n(50959);const a={},s=i.createContext(a);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:t},e.children)}}}]);